<!DOCTYPE html> <html> <head><meta name="generator" content="Hexo 3.9.0"> <script>var _hmt=_hmt||[]</script> <script async src="//hm.baidu.com/hm.js?3d88a42f36d311b6e2c830ea185ed398"></script> <script>!function(){var t=document.createElement("script");t.setAttribute("async",!0);var e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script> <meta charset="utf-8"> <link rel="canonical" href="https://coolcode.org"> <title>秒杀 tj/co 的 hprose 协程库</title> <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"> <meta name="theme-color" content="#3F51B5"> <meta name="keywords" content="hprose,协程,coroutine,async,promise"> <meta name="description" content="ES6 中引入了 Generator，Generator 通过封装之后，可以作为协程来进行使用。 其中对 Generator 封装最为著名的当属 tj/co，但是 tj/co 跟 ES2016 的 async/await 相比的话，还存在一些比较严重的缺陷。 hprose 中也引入了对 Generator 封装的协程支持，但是比 tj/co 更加完善，下面我们就来详细介绍一下它们之间的差别。"> <meta name="keywords" content="hprose,协程,coroutine,async,promise"> <meta property="og:type" content="article"> <meta property="og:title" content="秒杀 tj&#x2F;co 的 hprose 协程库"> <meta property="og:url" content="https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/index.html"> <meta property="og:site_name" content="CoolCode"> <meta property="og:description" content="ES6 中引入了 Generator，Generator 通过封装之后，可以作为协程来进行使用。 其中对 Generator 封装最为著名的当属 tj/co，但是 tj/co 跟 ES2016 的 async/await 相比的话，还存在一些比较严重的缺陷。 hprose 中也引入了对 Generator 封装的协程支持，但是比 tj/co 更加完善，下面我们就来详细介绍一下它们之间的差别。"> <meta property="og:locale" content="zh-CN"> <meta property="og:updated_time" content="2018-03-14T04:51:00.000Z"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="秒杀 tj&#x2F;co 的 hprose 协程库"> <meta name="twitter:description" content="ES6 中引入了 Generator，Generator 通过封装之后，可以作为协程来进行使用。 其中对 Generator 封装最为著名的当属 tj/co，但是 tj/co 跟 ES2016 的 async/await 相比的话，还存在一些比较严重的缺陷。 hprose 中也引入了对 Generator 封装的协程支持，但是比 tj/co 更加完善，下面我们就来详细介绍一下它们之间的差别。"> <link rel="alternate" type="application/atom+xml" title="CoolCode" href="../../../../atom.xml"> <link rel="shortcut icon" href="../../../../favicon.ico"> <link rel="stylesheet" href="../../../../css/style.css?v=1.7.2"> <script src="../../../../js/echarts.common.min.js?v=1.7.2"></script> <script>window.lazyScripts=[]</script> <link rel="manifest" href="/manifest.json"> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-precomposed-144x144.png"> <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/img/apple-touch-icon-precomposed-120x120.png"> <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/img/apple-touch-icon-precomposed-72x72.png"> <link rel="apple-touch-icon-precomposed" href="/img/apple-touch-icon-precomposed-57x57.png"> </head> <body> <div id="loading" class="active"></div> <aside id="menu"> <div class="inner flex-row-vertical"> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"> <i class="icon icon-lg icon-close"></i> </a> <div class="brand-wrap" style="background-image:url(../../../../img/brand.jpg)"> <div class="brand"> <a href="../../../../index.html" class="avatar waves-effect waves-circle waves-light"> <img src="../../../../img/avatar.jpg"> </a> <hgroup class="introduce"> <h5 class="nickname">小马哥</h5> <a href="mailto:andot@qq.com" title="andot@qq.com" class="mail">andot@qq.com</a> </hgroup> <ul class="menu-link"> <li> <a href="https://github.com/andot" target="_blank"> <i class="icon icon-lg icon-github"></i> </a> </li> <li> <a href="https://sighttp.qq.com/authd?IDKEY=0f7b6690eff38f1a1bc274af3639750f34b370fb0f86105f" target="_blank"> <i class="icon icon-lg icon-qq"></i> </a> </li> </ul> </div> </div> <div class="scroll-wrap flex-col"> <ul class="nav"> <li class="waves-block waves-effect"> <a href="../../../../index.html"> <i class="icon icon-lg icon-home"></i> 主页 </a> </li> <li class="waves-block waves-effect"> <a href="../../../../archives"> <i class="icon icon-lg icon-archives"></i> 归档 </a> </li> <li class="waves-block waves-effect"> <a href="../../../../tags"> <i class="icon icon-lg icon-tags"></i> 标签 </a> </li> <li class="waves-block waves-effect"> <a href="../../../../categories"> <i class="icon icon-lg icon-th-list"></i> 分类 </a> </li> <li class="waves-block waves-effect"> <a href="../../../../about"> <i class="icon icon-lg icon-id-card"></i> 关于 </a> </li> </ul> </div> </div> </aside> <main id="main"> <header class="top-header" id="header"> <div class="flex-row"> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"> <i class="icon icon-lg icon-navicon"></i> </a> <div class="flex-col header-title ellipsis">秒杀 tj/co 的 hprose 协程库</div> <div class="search-wrap" id="search-wrap"> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"> <i class="icon icon-lg icon-chevron-left"></i> </a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字"> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"> <i class="icon icon-lg icon-search"></i> </a> </div> <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare"> <i class="icon icon-lg icon-share-alt"></i> </a> </div> </header> <header class="content-header post-header"> <div class="container fade-scale"> <h1 class="title">秒杀 tj/co 的 hprose 协程库</h1> <h5 class="subtitle"> <time datetime="2016-11-22T16:00:00.000Z" itemprop="datePublished" class="page-time"> 2016年11月23日 </time> <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="../../../../categories/编程/">编程</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="../../../../categories/编程/JavaScript/">JavaScript</a></li></ul></li></ul> </h5> </div> </header> <div class="container body-wrap"> <aside class="post-widget"> <nav class="post-toc-wrap post-toc-shrink" id="post-toc"> <h4>目录</h4> <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#概述"><span class="post-toc-number">1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#yield-基本类型"><span class="post-toc-number">2.</span> <span class="post-toc-text">yield 基本类型</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#yield-数组或对象"><span class="post-toc-number">3.</span> <span class="post-toc-text">yield 数组或对象</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#yield-thunk-函数"><span class="post-toc-number">4.</span> <span class="post-toc-text">yield thunk 函数</span></a></li></ol> </nav> </aside> <article id="post-hprose-coroutine-library-for-javascript" class="post-article article-type-post fade" itemprop="blogPost"> <div class="post-card"> <h1 class="post-card-title">秒杀 tj/co 的 hprose 协程库</h1> <div class="post-meta"> <time class="post-time" title="2016年11月23日 00:00:00" datetime="2016-11-22T16:00:00.000Z" itemprop="datePublished">2016年11月23日</time> <ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="../../../../categories/编程/">编程</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="../../../../categories/编程/JavaScript/">JavaScript</a></li></ul></li></ul> <span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none"> <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span> </span> </div> <div class="post-content" id="post-content" itemprop="postContent"> <p>ES6 中引入了 Generator，Generator 通过封装之后，可以作为协程来进行使用。</p> <p>其中对 Generator 封装最为著名的当属 tj/co，但是 tj/co 跟 ES2016 的 async/await 相比的话，还存在一些比较严重的缺陷。</p> <p>hprose 中也引入了对 Generator 封装的协程支持，但是比 tj/co 更加完善，下面我们就来详细介绍一下它们之间的差别。</p> <a id="more"></a> <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://github.com/tj/co" target="_blank" rel="noopener"><code>tj/co</code></a> 有以下几个方面的问题：</p> <p>首先，<code>tj/co</code> 库中的 <code>yield</code> 只支持 thunk 函数，生成器函数，promise 对象，以及数组和对象，但是不支持普通的基本类型的数据，比如 <code>null</code>, 数字，字符串等都不支持。这对于 <code>yield</code> 一个类型不确定的变量来说，是很不方便的。而且这跟 <code>await</code> 也是不兼容的。</p> <p>其次，在 <code>yield</code> 数组和对象时，<code>tj/co</code> 库会自动对数组中的元素和对象中的字段递归的遍历，将其中的所有的 <code>Promise</code> 元素和字段替换为实际值，这对于简单的数据来说，会方便一些。但是对于带有循环引用的数组和对象来说，会导致无法获取到结果，这是一个致命的问题。即使对于不带有循环引用结构的数组和对象来说，如果该数组和对象比较复杂，这也会消耗大量的时间。而且这跟 <code>await</code> 也是不兼容的。</p> <p>再次，对于 thunk 函数，<code>tj/co</code> 库会认为回调函数第一个参数必须是表示错误，从第二个参数开始才表示返回值。而这对于回调函数只有一个返回值参数的函数，或者回调函数的第一个参数不表示错误的函数来说，<code>tj/co</code> 库就无法使用了。</p> <p>而 <code>hprose.co</code> 对 <code>yield</code> 的支持则跟 <code>await</code> 完全兼容，支持对所有类型的数据进行 <code>yield</code>。</p> <p>当 <code>hprose.co</code> 对 chunk 函数进行 <code>yield</code> 时，如果回调函数第一个参数是 <code>Error</code> 类型的对象才会被当做错误处理。如果回调函数只有一个参数且不是 <code>Error</code> 类型的对象，则作为返回值对待。如果回调函数有两个以上的参数，如果第一个参数为 <code>null</code> 或 <code>undefined</code>，则第一个参数被当做无错误被忽略，否则，全部回调参数都被当做返回值对待。如果被当做返回值的回调参数有多个，则这多个参数被当做数组结果对待，如果只有一个，则该参数被直接当做返回值对待。</p> <p>下面我们来举例说明一下：</p> <h1 id="yield-基本类型"><a href="#yield-基本类型" class="headerlink" title="yield 基本类型"></a>yield 基本类型</h1><p>首先我们来看一下 <code>tj/co</code> 库的例子：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="string">"promise"</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"generator"</span> &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="number">123</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="number">3.14</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="string">"hello"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> <p>该程序运行结果为：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">generator</span><br><span class="line">TypeError: You may only yield a function, promise, generator, array, or object, but the following object was passed: &quot;Sat Nov 19 2016 14:51:09 GMT+0800 (CST)&quot;</span><br><span class="line">    at next (/usr/local/lib/node_modules/co/index.js:101:25)</span><br><span class="line">    at onFulfilled (/usr/local/lib/node_modules/co/index.js:69:7)</span><br><span class="line">    at process._tickCallback (internal/process/next_tick.js:103:7)</span><br><span class="line">    at Module.runMain (module.js:577:11)</span><br><span class="line">    at run (bootstrap_node.js:352:7)</span><br><span class="line">    at startup (bootstrap_node.js:144:9)</span><br><span class="line">    at bootstrap_node.js:467:3</span><br></pre></td></tr></table></figure> <p>其实除了前两个，后面的几个基本类型的数据都不能被 <code>yield</code>。如果我们把上面代码的第一句改为：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'hprose'</span>).co;</span><br></pre></td></tr></table></figure> <p>后面的代码都不需要修改，我们来看看运行结果：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">generator</span><br><span class="line">2016-11-19T06:54:30.081Z</span><br><span class="line">123</span><br><span class="line">3.14</span><br><span class="line">hello</span><br><span class="line">true</span><br></pre></td></tr></table></figure> <p>也就是说，<code>hprose.co</code> 支持对所有类型进行 <code>yield</code> 操作。下面我们再来看看 async/await 是什么效果：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">"promise"</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="function"><span class="keyword">function</span> *(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"generator"</span> &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="number">123</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="number">3.14</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="string">"hello"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure> <p>上面的代码基本上就是把 <code>co(function*...)</code> 替换成了 <code>async function...</code>，把 <code>yield</code> 替换成了 <code>await</code>。</p> <p>我们来运行上面的程序，注意，对于当前版本的 node 运行时需要加上 <code>--harmony_async_await</code> 参数，运行结果如下：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">[Function]</span><br><span class="line">2016-11-19T08:16:25.316Z</span><br><span class="line">123</span><br><span class="line">3.14</span><br><span class="line">hello</span><br><span class="line">true</span><br></pre></td></tr></table></figure> <p>我们可以看出，<code>await</code> 和 <code>hprose.co</code> 除了对生成器的处理不同以外，其它的都相同。对于生成器函数，<code>await</code> 是按原样返回的，而 <code>hprose.co</code> 则是按照 <code>tj/co</code> 的方式处理。也就是说 <code>hprose.co</code> 综合了 <code>await</code> 和 <code>tj/co</code> 的全部优点。使用 <code>hprose.co</code> 比使用 <code>await</code> 或 <code>tj/co</code> 都方便。</p> <h1 id="yield-数组或对象"><a href="#yield-数组或对象" class="headerlink" title="yield 数组或对象"></a>yield 数组或对象</h1><p>我们来看第二个让 <code>tj/co</code> 崩溃的例子：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a = [];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        <span class="keyword">var</span> end = <span class="built_in">Date</span>.now();;</span><br><span class="line">        <span class="built_in">console</span>.log(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a = [];</span><br><span class="line">        a[<span class="number">0</span>] = a;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">        o.self = o;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">yield</span> o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> <p>运行该程序，我们会看到程序会卡一会儿，然后出现下面的结果：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2530</span><br><span class="line">(node:70754) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): RangeError: Maximum call stack size exceeded</span><br><span class="line">(node:70754) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br><span class="line">(node:70754) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure> <p>上面的 <code>2530</code> 是第一个 <code>co</code> 程序段输出的结果，也就是说这个 <code>yield</code> 要等待 2.5 秒才能返回结果。而后面两个 <code>co</code> 程序段则直接调用栈溢出了。如果在实际应用中，出现了这样的数据，使用 <code>tj/co</code> 你的程序就会变得很慢，或者直接崩溃了。</p> <p>下面看看 <code>hprose.co</code> 的效果，同样只替换第一句话为：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'hprose'</span>).co;</span><br></pre></td></tr></table></figure> <p>后面的代码都不需要修改，我们来看看运行结果：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">[ [Circular] ]</span><br><span class="line">&#123; self: [Circular] &#125;</span><br></pre></td></tr></table></figure> <p>第一个 <code>co</code> 程序段用时很短，只需要 <code>7</code> ms。注意，这还是包含了后面两个程序段的时间，因为这三个协程是并发的，如果去掉后面两个程序段，你看的输出可能是 <code>1</code> ms 或者 <code>0</code> ms。而后面两个程序段也完美的返回了带有循环引用的数据。这才是我们期望的结果。</p> <p>我们再来看看 <code>async/await</code> 下是什么效果，程序代码如下：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a = [];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            a[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">await</span> a;</span><br><span class="line">        <span class="keyword">var</span> end = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="built_in">console</span>.log(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a = [];</span><br><span class="line">        a[<span class="number">0</span>] = a;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">        o.self = o;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure> <p>运行结果如下：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14</span><br><span class="line">[ [Circular] ]</span><br><span class="line">&#123; self: [Circular] &#125;</span><br></pre></td></tr></table></figure> <p>我们发现 <code>async/await</code> 的输出结果跟 <code>hprose.co</code> 是一致的，但是在性能上，<code>hprose.co</code> 则比 <code>async/await</code> 还要快 1 倍。因此，第二个回合，<code>hprose.co</code> 仍然是完胜 <code>tj/co</code> 和 <code>async/await</code>。</p> <h1 id="yield-thunk-函数"><a href="#yield-thunk-函数" class="headerlink" title="yield thunk 函数"></a>yield thunk 函数</h1><p>我们再来看看 <code>tj/co</code> 和 <code>tj/thunkify</code> 是多么的让人抓狂，以及 <code>hprose.co</code> 和 <code>hprose.thunkify</code> 是如何优雅的解决 <code>tj/co</code> 和 <code>tj/thunkify</code> 带来的这些让人抓狂的问题的。</p> <p>首先我们来看第一个问题：</p> <p><code>tj/thunkify</code> 返回的 thunk 函数的执行结果是一次性的，不能像 <code>promise</code> 结果那样被使用多次，我们来看看下面这个例子：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">"co"</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">"thunkify"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = thunkify(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">    callback(<span class="literal">null</span>, a + b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> result);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> sum(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> <p>这个例子很简单，输出结果你猜是啥？</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></table></figure> <p>是上面的结果吗？恭喜你，答错了！不过，这不是你的错，而是 <code>tj/thunkify</code> 的错，它的结果是：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure> <p>什么？最后的 <code>console.log(yield result)</code> 输出结果哪儿去了？不好意思，<code>tj/thunkify</code> 解释说是为了防止 <code>callback</code> 被重复执行，所以就只能这么玩了。可是真的是这样吗？</p> <p>我们来看看使用 <code>hprose.co</code> 和 <code>hprose.thunkify</code> 的执行结果吧，把开头两行换成下面三行：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hprose = <span class="built_in">require</span>(<span class="string">"hprose"</span>);</span><br><span class="line"><span class="keyword">var</span> co = hprose.co;</span><br><span class="line"><span class="keyword">var</span> thunkify = hprose.thunkify;</span><br></pre></td></tr></table></figure> <p>其它代码都不用改，运行它，你会发现预期的结果出来了，就是：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></table></figure> <p>可能你还不服气，你会说，<code>tj/thunkify</code> 这样做是为了防止类似被 <code>thunkify</code> 的函数中，回调被多次调用时，<code>yield</code> 的结果不正确，比如：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = thunkify(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">    callback(<span class="literal">null</span>, a + b);</span><br><span class="line">    callback(<span class="literal">null</span>, a + b + a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> result);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> sum(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> <p>如果 <code>tj/thunkify</code> 不这样做，结果可能就会变成：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure> <p>可是真的是这样吗？你会发现，即使改成上面的样子，<code>hprose.thunkify</code> 配合 <code>hprose.co</code> 返回的结果仍然是：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></table></figure> <p>跟预期的一样，回调函数并没有重复执行，错误的结果并没有出现。而且当需要重复 <code>yield</code> 结果函数时，还能够正确得到结果。</p> <p>最后我们再来看一下，<code>tj/thunkify</code> 这样做真的解决了问题了吗？我们把代码改成下面这样：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = thunkify(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"call sum("</span> + <span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>) + <span class="string">")"</span>);</span><br><span class="line">    callback(<span class="literal">null</span>, a + b);</span><br><span class="line">    callback(<span class="literal">null</span>, a + b + a);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> result);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> sum(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> <p>然后替换不同的 <code>co</code> 和 <code>thunkify</code>，然后执行，我们会发现，<code>tj</code> 版本的输出如下：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call sum(1,2,function ()&#123;</span><br><span class="line">        if (called) return;</span><br><span class="line">        called = true;</span><br><span class="line">        done.apply(null, arguments);</span><br><span class="line">      &#125;)</span><br><span class="line">3</span><br><span class="line">call sum(2,3,function ()&#123;</span><br><span class="line">        if (called) return;</span><br><span class="line">        called = true;</span><br><span class="line">        done.apply(null, arguments);</span><br><span class="line">      &#125;)</span><br><span class="line">5</span><br><span class="line">call sum(1,2,function ()&#123;</span><br><span class="line">        if (called) return;</span><br><span class="line">        called = true;</span><br><span class="line">        done.apply(null, arguments);</span><br><span class="line">      &#125;,function ()&#123;</span><br><span class="line">        if (called) return;</span><br><span class="line">        called = true;</span><br><span class="line">        done.apply(null, arguments);</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure> <p>而 <code>hprose</code> 版本的输出结果如下：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call sum(1,2,function () &#123;</span><br><span class="line">                thisArg = this;</span><br><span class="line">                results.resolve(arguments);</span><br><span class="line">            &#125;)</span><br><span class="line">3</span><br><span class="line">call sum(2,3,function () &#123;</span><br><span class="line">                thisArg = this;</span><br><span class="line">                results.resolve(arguments);</span><br><span class="line">            &#125;)</span><br><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></table></figure> <p>从这里，我们可以看出，<code>tj</code> 版本的程序在执行第二次 <code>yield result</code> 时，简直错的离谱，它不但没有让我们得到预期的结果，反而还重复执行了 <code>thunkify</code> 后的函数，而且带入的参数也完全不对了，所以，这是一个完全错误的实现。</p> <p>而从 <code>hprose</code> 版本的输出来看，<code>hprose</code> 不但完美的避免了回调被重复执行，而且保证了被 <code>thunkify</code> 后的函数执行的结果被多次 <code>yield</code> 时，也不会被重复执行，而且还能够得到预期的结果，可以实现跟返回 promise 对象一样的效果。</p> <p><code>tj</code> 因为没有解决他所实现的 <code>thunkify</code> 函数带来的这些问题，所以在后期推荐大家放弃 <code>thunkify</code>，转而投奔到返回 <code>promise</code> 对象的怀抱中，而实际上，这个问题并非是不能解决的。</p> <p><code>hprose</code> 在对 <code>thunkify</code> 函数的处理上，再次完胜 <code>tj</code>。而这个回合中，<code>async/await</code> 就不用提了，因为 <code>async/await</code> 完全不支持对 thunk 函数进行 <code>await</code>。</p> <p>这还不是 <code>hprose.co</code> 和 <code>hprose.thunkify</code> 的全部呢，再继续看下面这个例子：</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = thunkify(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">    callback(a + b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> result);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> sum(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span> result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> <p>这里开头对 <code>hprose</code> 和 <code>tj</code> 版本的不同 <code>co</code> 和 <code>thunkify</code> 实现的引用就省略了，请大家自行脑补。</p> <p>上面这段程序，如果使用 <code>tj</code> 版本的 <code>co</code> 和 <code>thunkify</code> 实现，运行结果是这样的：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(node:75927) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 2): 3</span><br><span class="line">(node:75927) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br></pre></td></tr></table></figure> <p>而如果使用 <code>hprose</code> 版本的 <code>co</code> 和 <code>thunkify</code> 实现，运行结果是这样的：</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">3</span><br></pre></td></tr></table></figure> <p><code>hprose</code> 版本的运行结果再次符合预期，而 <code>tj</code> 版本的运行结果再次让人失望之极。</p> <p>进过上面三个回合的较量，我们发现 hprose 的协程完胜 <code>tj</code> 和 <code>async/await</code>，而且 <code>tj</code> 的实现是惨败，<code>async/await</code> 虽然比 <code>tj</code> 稍微好那么一点，但是跟 <code>hprose</code> 所实现协程比起来，也是望尘莫及。</p> <p>所以，用 <code>tj/co</code> 和 <code>async/await</code> 感觉很不爽的同学，可以试试 <code>hprose.co</code> 了，绝对让你爽歪歪。</p> <p>hprose 有 4 个 JavaScript 版本，它们都支持上面的协程库，它们的地址分别是：</p> <ul> <li><a href="https://github.com/hprose/hprose-nodejs" target="_blank" rel="noopener">hprose for Node.js</a> 【<a href="https://git.coding.net/andot/hprose-nodejs.git" target="_blank" rel="noopener">coding镜像</a>】</li> <li><a href="https://github.com/hprose/hprose-html5" target="_blank" rel="noopener">hprose for HTML5</a> 【<a href="https://git.coding.net/andot/hprose-html5.git" target="_blank" rel="noopener">coding镜像</a>】</li> <li><a href="https://github.com/hprose/hprose-js" target="_blank" rel="noopener">hprose for JavaScript</a> 【<a href="https://git.coding.net/andot/hprose-js.git" target="_blank" rel="noopener">coding镜像</a>】</li> <li><a href="https://github.com/hprose/hprose-wx" target="_blank" rel="noopener">hprose for 微信小程序</a> 【<a href="https://git.coding.net/andot/hprose-wx.git" target="_blank" rel="noopener">coding镜像</a>】</li> </ul> <p>另外，如果你不需要使用 hprose 序列化和远程调用的话，下面还有一个专门的从 hprose 中精简出来的 Promise A+ 实现和协程库：<a href="https://github.com/andot/future-js" target="_blank" rel="noopener">Future.js</a> 【<a href="https://git.oschina.net/hprose/future-js" target="_blank" rel="noopener">coding镜像</a>】</p> <p>当然该协程库的功能不止于此，更多介绍请参见：</p> <ul> <li><a href="https://github.com/hprose/hprose-nodejs/wiki/Promise-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">Promise 异步编程</a></li> <li><a href="https://github.com/hprose/hprose-nodejs/wiki/%E5%8D%8F%E7%A8%8B" target="_blank" rel="noopener">协程</a></li> </ul> </div> <blockquote class="post-copyright"> <div class="content"> <span class="post-time"> 最后更新时间：<time datetime="2018-03-14T04:51:00.000Z" itemprop="dateUpdated">2018年03月14日 12:51:00</time> </span><br> 本文共计 3,143 字，阅读时长预计 13 分钟<br>转载注明出处，原文地址：<a href="" target="_blank" rel="external">https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/</a> </div> <footer> <a href="https://coolcode.org"> <img src="../../../../img/avatar.jpg" alt="小马哥"> 小马哥 </a> </footer> </blockquote> <div class="page-reward"> <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a> </div> <div class="post-footer"> <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/async/">async</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/coroutine/">coroutine</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/hprose/">hprose</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/promise/">promise</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="../../../../tags/协程/">协程</a></li></ul> <div class="page-share-wrap"> <div class="page-share" id="pageShare"> <ul class="reset share-icons"> <li> <a class="weibo share-sns" target="_blank" href="https://service.weibo.com/share/share.php?url=https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/&title=《秒杀 tj/co 的 hprose 协程库》 — CoolCode&pic=https://coolcode.org/img/avatar.jpg" data-title="微博"> <i class="icon icon-weibo"></i> </a> </li> <li> <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"> <i class="icon icon-weixin"></i> </a> </li> <li> <a class="qq share-sns" target="_blank" href="https://connect.qq.com/widget/shareqq/index.html?url=https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/&title=《秒杀 tj/co 的 hprose 协程库》 — CoolCode&source=ES6 中引入了 Generator，Generator 通过封装之后，可以作为协程来进行使用。
其中对 Generator 封装最为著名的当属 tj/c..." data-title=" QQ"> <i class="icon icon-qq"></i> </a> </li> <li> <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/" data-title=" Facebook"> <i class="icon icon-facebook"></i> </a> </li> <li> <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《秒杀 tj/co 的 hprose 协程库》 — CoolCode&url=https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/&via=https://coolcode.org" data-title=" Twitter"> <i class="icon icon-twitter"></i> </a> </li> <li> <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/" data-title=" Google+"> <i class="icon icon-google-plus"></i> </a> </li> </ul> </div> <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"> <i class="icon icon-share-alt icon-lg"></i> </a> </div> </div> </div> <nav class="post-nav flex-row flex-justify-between"> <div class="waves-block waves-effect prev"> <a href="../../../../2017/09/12/my-japanese-learning-notes/" id="post-prev" class="post-nav-link"> <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div> <h4 class="title">我的日语学习笔记</h4> </a> </div> <div class="waves-block waves-effect next"> <a href="../../08/a-brief-analysis-of-serialization-and-deserialization/" id="post-next" class="post-nav-link"> <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div> <h4 class="title">序列化和反序列化浅析</h4> </a> </div> </nav> <section class="comments" id="comments"> <div id="gitment_thread"></div> <script type="text/javascript" src="../../../../js/gitment.browser.min.js?v=1.7.2"></script> <script>var gitment=new Gitmint({lang:"zh-CN",owner:"andot",repo:"CoolCode",id:"秒杀 tj/co 的 hprose 协程库",oauth:{client_id:"0dfa8bd57a3253425991",client_secret:"cc7af9e85ee4abda607ea1a5d5a0f55e1e6c256a"}});gitment.render("comments")</script> </section> </article> <div id="reward" class="page-modal reward-lay"> <a class="close" href="javascript:;"><i class="icon icon-close"></i></a> <h3 class="reward-title"> <i class="icon icon-quote-left"></i> 感谢您的支持~ <i class="icon icon-quote-right"></i> </h3> <div class="reward-content"> <div class="reward-code"> <img id="rewardCode" src="../../../../img/wechat.jpg" alt="打赏二维码"> </div> <label class="reward-toggle"> <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="../../../../img/wechat.jpg" data-alipay="../../../../img/alipay.jpg"> <div class="reward-toggle-ctrol"> <span class="reward-toggle-item wechat">微信</span> <span class="reward-toggle-label"></span> <span class="reward-toggle-item alipay">支付宝</span> </div> </label> </div> </div> </div> <footer class="footer"> <div class="bottom"> <p> <span id="busuanzi_container_site_uv"> 站点总访客数：<span id="busuanzi_value_site_uv"><i class="icon icon-lg icon-spinner"></i></span> </span> <span id="busuanzi_container_site_pv"> 站点总访问量：<span id="busuanzi_value_site_pv"><i class="icon icon-lg icon-spinner"></i></span> </span> </p> <p> <span><a href="../../../../atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span> <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span> </p> <p> <span>小马哥 &copy; 2005 - 2020</span> <span> <a href="http://www.miitbeian.gov.cn/" target="_blank">鲁ICP备17003119号-8</a> </span><span>Power by <a href="https://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span> <span>Hosted by <a href="https://pages.github.com" style="font-weight:700">GitHub Pages</a></span> </p> </div> </footer> </main> <div class="mask" id="mask"></div> <a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a> <div class="global-share" id="globalShare"> <ul class="reset share-icons"> <li> <a class="weibo share-sns" target="_blank" href="https://service.weibo.com/share/share.php?url=https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/&title=《秒杀 tj/co 的 hprose 协程库》 — CoolCode&pic=https://coolcode.org/img/avatar.jpg" data-title="微博"> <i class="icon icon-weibo"></i> </a> </li> <li> <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"> <i class="icon icon-weixin"></i> </a> </li> <li> <a class="qq share-sns" target="_blank" href="https://connect.qq.com/widget/shareqq/index.html?url=https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/&title=《秒杀 tj/co 的 hprose 协程库》 — CoolCode&source=ES6 中引入了 Generator，Generator 通过封装之后，可以作为协程来进行使用。
其中对 Generator 封装最为著名的当属 tj/c..." data-title=" QQ"> <i class="icon icon-qq"></i> </a> </li> <li> <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/" data-title=" Facebook"> <i class="icon icon-facebook"></i> </a> </li> <li> <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《秒杀 tj/co 的 hprose 协程库》 — CoolCode&url=https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/&via=https://coolcode.org" data-title=" Twitter"> <i class="icon icon-twitter"></i> </a> </li> <li> <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://coolcode.org/2016/11/22/hprose-coroutine-library-for-javascript/" data-title=" Google+"> <i class="icon icon-google-plus"></i> </a> </li> </ul> </div> <div class="page-modal wx-share" id="wxShare"> <a class="close" href="javascript:;"><i class="icon icon-close"></i></a> <p>扫一扫，分享到微信</p> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsElEQVR42u3asVYjMQwF0Pz/T7MtxTJ5T5YhxZ2KA8Hj68JSJL1e8fP17Ul+kzzPb/lp/deNBw8PD+9g689LP2Oe109+/mm19ijx8PDwfoeXbysJG8/rPK+cH8fzu/Dw8PA+jZdf1iefzw8FDw8P75N559d6/vY/CAx4eHh4Ma8toeYBoC3ytkXktVoLHh4eXrdC1EX6nJ+v9Pfw8PDwjrvqs2b/c4KbFykWdouHh4d3gZdfuCdp6wkpabC9+SQeHh7eBd55oXbWuJqNESSjWnh4eHi3ebOLO0+jZ6EiaW5FoQUPDw9vlZcXC7ZS59k6bTMMDw8P73d4s3JAHhhmjf+T8IOHh4d3g5eUIdriQn5wbVPtqBiBh4eHt8rLhwCSy70NP+chJwoVeHh4eEu89sU58qRE265Tjwvg4eHhHfDaLeaJ7Cxg5CsUhWY8PDy8C7z6i31Zij0HL5Q58PDw8FZ57XBAjmwT4nZgK/pfPDw8vFXebvsqgc1S5LxoUnT28PDw8JZ4u4l1XvBtS7TJfvDw8PBu8O6NOi0UXg/udjw8PLx7vISxMM81Or72LVExAg8PD2+Jl6ezs0Q5ue5nweDNAeHh4eFd4CWXeN6+2hrqmqXaRaDCw8PDu8xL/vk8Xc7LDe1v8PDw8G7w8sQ3DxWz4uzWxFRUw8DDw8M75j0vMcMkhYnz5PvNW/Dw8PCu8fKxgOTuzUsG7RG0UQAPDw9vl/dVPnnZ9HwAqw0A//krHh4e3gXe7MJtxwVmjbR8COw8nODh4eG1vK0SwPMVn280aYAVgQEPDw/vGq8dbJqxd0evon3i4eHhfQCv/cLfljna8kfRAMPDw8P7I95JeGiPLAkqb44bDw8P7xrv5MqebT0PQu0gAh4eHt5tXvuFv02gZ5/Mm2oLDx4eHl66n38Cu0rfMj/btQAAAABJRU5ErkJggg==" alt="微信分享二维码"> </div> <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script> <script>var BLOG={ROOT:"/",SHARE:!0,REWARD:!0}</script> <script src="../../../../js/main.min.js?v=1.7.2"></script> <div class="search-panel" id="search-panel"> <ul class="search-result" id="search-result"></ul> </div> <template id="search-tpl"> <li class="item"> <a href="{path}" class="waves-block waves-effect"> <div class="title ellipsis" title="{title}">{title}</div> <div class="flex-row flex-middle"> <div class="tags ellipsis"> {tags} </div> <time class="flex-col time">{date}</time> </div> </a> </li> </template> <script src="../../../../js/search.min.js?v=1.7.2" async></script> <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> </body> </html> 